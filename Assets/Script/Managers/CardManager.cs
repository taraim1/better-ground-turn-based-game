using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using UnityEngine;
using DG.Tweening;
using UnityEngine.SceneManagement;
using System.IO;
using DG.Tweening.Plugins.Core.PathCore;

// 스킬카드 코드
public enum skillcard_code
{
    simple_attack,
    simple_defend,
    simple_dodge,
    powerful_attack,
    fire_ball,
    concentration,
    fire_enchantment
}

public class CardManager : Singletone<CardManager>
{
    [SerializeField] CardDataSO CardDataSO;
    [SerializeField] Transform card_spawnpoint;
    [SerializeField] Transform leftData_transform;
    [SerializeField] Transform leftData_over4_transform;
    [SerializeField] Transform rightData_transform;
    [SerializeField] Transform rightData_over4_transform;
    [SerializeField] Transform diactivatedData_transform;
    [SerializeField] Transform highlightedData_transform;
    [SerializeField] Transform enemyData_transform;
    [SerializeField] Transform enemyData_highlighted_transform;

    // 기타 카드 정보 담은 클래스
    private class card_data_json 
    {
        // 카드 언락 데이터가 들어가는 리스트 (i번은 i번 스킬 언락유무)
        public List<bool> unlockedData_checkList;

        // 데이터 불러오기
        public void read_json() 
        { 
            string output = File.ReadAllText(Application.dataPath + "/Data/skillData.json");
            this.unlockedData_checkList = JsonUtility.FromJson<card_data_json>(output).unlockedData_checkList;
        }

        // 데이터 저장하기
        public void write_json() 
        {
            string output = JsonUtility.ToJson(this, true);
            File.WriteAllText(Application.dataPath + "/Data/skillData.json", output);
        }
    }

    card_data_json JsonCardData = new card_data_json();

    // 캐릭터들의 덱이 랜덤으로 섞여 들어가는 버퍼
    List<List<CardData>> CardData_buffer = new List<List<CardData>>();

    public GameObject card_prefab;

    // 현재 보는 중인 캐릭터 카드패의 인덱스, 안 보는 중이면 -1
    public int active_index;

    // 현재 강조 중인 카드
    public card highlightedData;

    // 카드 효과 설명해주는 오브젝트가 가지고 있는 거
    private card_description card_Description;

    private bool _isCharacterDragging = false;

    private void Start()
    {
        JsonCardData.read_json();
    }

    // 카드 코드 주면 카드 데이터 줌
    public CardData getData_by_code(skillcard_code code) 
    {
        return CardDataSO.CardData_dict[code];
    }


    // 카드 코드 주면 언락된건지 찾아줌
    public bool check_unlocked(skillcard_code code) 
    {
        return JsonCardData.unlockedData_checkList[(int)code];
    }

    public void set_unlocked(skillcard_code code, bool value) 
    {
        JsonCardData.unlockedData_checkList[(int)code] = value;
        JsonCardData.write_json();
    }

    // index번째 캐릭터의 덱 버퍼에서 첫 카드 뽑기
    public CardData PopCard(int index) 
    {
        if (CardData_buffer[index].Count == 0) SetupDataBuffer();

        CardData card = CardData_buffer[index][0];
        CardData_buffer[index].RemoveAt(0);
        return card;
    }

    void SetupDataBuffer() // 버퍼 초기화
    { 
        CardData_buffer.Clear();

        // 버퍼에 카드들 추가
        for (int i = 0; i < BattleManager.instance.playable_characters.Count; i++) 
        {
            List<CardData> temp = new List<CardData>();
            List<skillcard_code> deck = BattleManager.instance.playable_characters[i].GetComponent<Character>().Get_deck_copy();

            // 파티의 캐릭터마다의 덱에서 코드를 얻어서 카드 데이터를 불러옴
            for (int j = 0; j < deck.Count; j++) 
            {
                // 스크립터블 오브젝트에서 데이터를 뽑아옴
                CardData tempCard = getData_by_code(deck[j]);
                temp.Add(tempCard);
                
            }

            CardData_buffer.Add(temp);
        }

        // 덱 버퍼 섞기
        for (int i = 0; i < CardData_buffer.Count; i++) 
        {
            for (int j = 0; j < CardData_buffer[i].Count; j++)
            {
                int rand = UnityEngine.Random.Range(0, CardData_buffer[i].Count);
                CardData temp = CardData_buffer[i][j];
                CardData_buffer[i][j] = CardData_buffer[i][rand];
                CardData_buffer[i][rand] = temp;
            }
        }

        
    }

    public void SummonData(int index) // 카드 생성 후 index번째의 패에 추가
    {
     
        var cardObj = Instantiate(card_prefab, card_spawnpoint.position, Quaternion.identity);
        if (index != active_index)
        {
            cardObj.transform.position = diactivatedData_transform.position;
        }
        card card = cardObj.GetComponent<card>();
        // index번째 캐릭터의 덱에서 카드를 뽑아옴
        card.Setup(PopCard(index), index);
        card.owner = BattleManager.instance.playable_characters[index];
        BattleManager.instance.hand_data[index].Add(card);

        Set_origin_order(index);
        Align_cards(index);
    }

    public GameObject Summon_enemyData(skillcard_code code, GameObject owner) // 적 카드 생성해서 리턴
    {

        var cardObj = Instantiate(card_prefab, enemyData_transform.position, Quaternion.identity);
        card card = cardObj.GetComponent<card>();
        card.owner = owner;
        card.isEnemyCard = true;
        card.originPRS = new PRS(enemyData_transform.position, enemyData_transform.rotation, Vector3.one * 1.5f);
        card.Setup(getData_by_code(code), 0);

        return cardObj;
    }

    public void OnCardDestroyed(card card)
    {
        // 카드 정렬
        Align_cards(active_index);
    }

    // 적 카드를 강조
    public void highlight_enemyData(GameObject obj) 
    {
        card card = obj.GetComponent<card>();
        PRS prs = new PRS(enemyData_highlighted_transform.position, enemyData_highlighted_transform.rotation, Vector3.one * 2.2f);
        card.MoveTransform(prs, true, 0.4f);
        card.state = card.current_mode.highlighted_enemyData;

    }


    public void Set_origin_order(int index) // 카드 orderInLayer설정
    {
        if (index == -1) { return; }

        for (int i = 0; i < BattleManager.instance.hand_data[index].Count; i++) 
        {
            BattleManager.instance.hand_data[index][i].GetComponent<element_order>().Set_origin_order(i);
        }
    }



    public void Align_cards(int index) // index번째 패의 카드 위치, 회전, 스케일, 순서 등 정렬 
    {
        // 현재 보고 있는 패가 없을 때의 active_index
        if (index == -1) 
        {
            return;
        }

        List<PRS> originDatas_PRS;
        if (BattleManager.instance.hand_data[index].Count >= 4) 
        {
            originDatas_PRS = setData_alignment(leftData_over4_transform, rightData_over4_transform, BattleManager.instance.hand_data[index].Count, 0.5f, Vector3.one * 1.8f, index);
        }
        else 
        {
            originDatas_PRS = setData_alignment(leftData_transform, rightData_transform, BattleManager.instance.hand_data[index].Count, 0.5f, Vector3.one * 1.8f, index);
        }
        

        // 드래그 중인 카드가 있는지 검사
        bool isdragging = false;
        for (int j = 0; j < BattleManager.instance.hand_data[index].Count; j++)
        {
            if (BattleManager.instance.hand_data[index][j].state == card.current_mode.dragging)
            {
                isdragging = true;
            }
        }

        for (int i = 0; i < BattleManager.instance.hand_data[index].Count; i++) 
        {
            card targetCard = BattleManager.instance.hand_data[index][i];

            targetCard.originPRS = originDatas_PRS[i];
            
            // 카드 겹침 때문에 보정값 넣어줌
            targetCard.originPRS.pos.z -= targetCard.GetComponent<element_order>().Get_order()/100f;

            // 드래그 중인 카드나 캐릭터가 있다면 드래그 중이 아닌 카드들을 살짝 아래로 내림
            if (isdragging || _isCharacterDragging) 
            {
                if (targetCard.state != card.current_mode.dragging)
                {
                    targetCard.originPRS.pos.y -= 2f;
                }
                else 
                {
                    targetCard.originPRS.pos.y -= 0.3f;
                }
            }

            // 활성화된 카드면
            if (index == active_index)
            {

                // 하이라이트된 카드면
                if (targetCard == highlightedData)
                {
                    // 드래그 중인 카드가 없다면
                    if (!isdragging) 
                    {
                        targetCard.MoveTransform(new PRS(new Vector3(highlightedData_transform.position.x, highlightedData_transform.position.y, targetCard.originPRS.pos.z), highlightedData_transform.rotation, Vector3.one * 2f), true, 0.2f);
                    }
                    
                    continue;
                }

                // 일반 카드면

                targetCard.MoveTransform(targetCard.originPRS, true, 0.3f);

                          
            }
            // 비활성화 카드면 밑으로 내려감
            else 
            {
                targetCard.MoveTransform(targetCard.originPRS, false, 0f);
            }

        }

     
    }

    List<PRS> setData_alignment(Transform leftTr, Transform rightTr, int CardCount, float height, Vector3 scale, int index) // 카드들의 PRS값 리스트를 계산해 반환
    {
        float[] objLerps = new float[CardCount];
        List<PRS> results = new List<PRS>(CardCount);

        // 활성화중인 패가 아닌 경우
        if (index != active_index) 
        {
            for (int i = 0; i < CardCount; i++) 
            {
                results.Add(new PRS(diactivatedData_transform.position, diactivatedData_transform.rotation, scale));
            }
            return results;
        }

        // 간격조정
        switch (CardCount) 
        {
            case 1: objLerps = new float[] { 0.5f }; break;
            case 2: objLerps = new float[] { 0.25f, 0.75f }; break;
            case 3: objLerps = new float[] { -0.5f, 0.5f, 1f }; break;
            default:
                float interval = 1f / (CardCount - 1);
                for (int i = 0; i < CardCount; i++) 
                {
                    objLerps[i] = interval * i;
                }
                break;
        }

        // 위치 계산
        for (int i = 0; i < CardCount; i++) 
        {
            var targetPos = Vector3.Lerp(leftTr.position, rightTr.position, objLerps[i]);
            var targetRot = Quaternion.identity;
            if (CardCount >= 4) 
            {
                float curve = Mathf.Sqrt(Mathf.Pow(height, 2) - Mathf.Pow(objLerps[i] - 0.5f, 2));
                targetPos.y += (curve-0.5f);
                targetRot = Quaternion.Slerp(leftTr.rotation, rightTr.rotation, objLerps[i]);
            }

            results.Add(new PRS(targetPos, targetRot, scale));
        }

        return results;
    }


    public void Change_active_hand(int index) // index번째 패 활성화
    {
        active_index = index;
        for (int i = 0; i < BattleManager.instance.hand_data.Count; i++) 
        {
                Align_cards(i);
        }
    }

    public void highlightData(card card) // 카드 하이라이트
    {
        highlightedData = card;
        card_Description.Set_target(card);
    }

    public void clear_highlighted_card() // 카드 하이라이트 해제
    {
        highlightedData = null;
        card_Description.Clear_target();
    }

    private void On_character_drag_start() 
    {
        _isCharacterDragging = true;
        Align_cards(active_index);
    }

    private void On_character_drag_end()
    {
        _isCharacterDragging = false;
        Align_cards(active_index);
    }

    private void OnCharacterDied(Character character) 
    {
        // 패 숨기기
        Change_active_hand(-1);
    }
    public void Setup_all() // 처음 세팅
    {
        SetupDataBuffer();
        active_index = -1;
        card_Description = GameObject.Find("card_description_base").GetComponent<card_description>();
        clear_highlighted_card();
    }

    private void OnEnable()
    {
        ActionManager.character_drag_started += On_character_drag_start;
        ActionManager.character_drag_ended += On_character_drag_end;
        ActionManager.character_died += OnCharacterDied;
        ActionManager.card_destroyed += OnCardDestroyed;
    }

    private void OnDisable()
    {
        ActionManager.character_drag_started -= On_character_drag_start;
        ActionManager.character_drag_ended -= On_character_drag_end;
        ActionManager.character_died -= OnCharacterDied;
        ActionManager.card_destroyed -= OnCardDestroyed;
    }


}
